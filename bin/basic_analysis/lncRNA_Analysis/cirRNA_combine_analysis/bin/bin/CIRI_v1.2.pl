use 5.010001;
$| = 1;
open STDERR, ">>./CIRIerror.log" or die;
my $timeA = time;
use Getopt::Long;
Getopt::Long::GetOptions(
	'PE|P!'	=>	\$PE,
	'SE|S!'	=>	\$SE,
	'in|I=s'	=>	\$sam,
	'out|O=s'	=>	\$cRNA_out,
	'read-length|L=i'	=> \$read_length,
	'anno|A=s'	=>	\$anno_gtf,
	'ref-dir|R=s'	=>	\$ref_dir,
	'ref-file|F=s'	=>	\$ref_1file,
	'log|G=s'	=>	\$log,
	'help|h!'	=>	\$help,
	'max-span|M=i'	=>	\$max_circle,
	'high-strigency|high!'	=>	\$high,
	'low-strigency|low!'	=>	\$low,
	'no-strigency|0!'	=>	\$no_strigency,
	'if_gtag|x=i'	=> \$if_gtag,
	'mapq_uni|u=i'	=> \$mapq_uni,
	'mapq_both|b=i'	=> \$mapq_both,
	'ident_exon_filter|E!'	=>	\$identical_exon_filter,
	'ident_exon_dist|T=i'	=>	\$identical_exon_dist,
	'ident_exon_length|N=i'	=>	\$identical_exon_length,
	'rel_exp|RE=f'	=>	\$rel_exp
);
if(!defined($PE) and !defined($SE) and !defined($sam) and !defined($cRNA_out) and !defined($read_length) and !defined($anno_gtf) and !defined($ref_dir) and !defined($log) and !defined($help) and !defined($max_circle)){	#
	print "Please use the --help or -H option to get usage information.\n";
	die;
}elsif(defined($help)){
	print "This is CIRI version 1.1, a detection tool for circRNAs. Welcome!\n\n";
	print "Written by Yuan Gao. Any questions please mail to gaoyuan06\@mails.ucas.ac.cn.\n\n";
	print "Usage of CIRI:\n";
	print "for paired-end reads: perl CIRI.pl -I in.sam -O output.ciri -F ref.fa (-R ref_dir/)\n";
	print "for single-end reads: perl CIRI.pl -I in.sam -O output.ciri -F ref.fa (-R ref_dir/) -S\n\n";
	print "Arguments:\n";
	print "\t--PE or -P\t\t\tPE reads as input (default)\n";
	print "\t--SE or -S\t\t\tSE reads as input\n";
	print "\t--in or -I\t\t\tinput SAM file name (required; generated by BWA-MEM)\n";
	print "\t--out or -O\t\t\toutput circRNA list name (required)\n";
	print "\t--read-length or -L\tread length of sequencing data (required)\n";
	print "\t--anno or -A\t\t\tinput GTF/GFF3 formatted annotation file name (optional)\n";
	print "\t--ref-dir or -R\t\t\tdirectory of reference sequence(s). Please make sure files in this directory are from the FASTA file(s) provided to BWA-MEM. Either this argument or --ref-file/-F is required for splicing signal searching.\n";
	print "\t--ref-file or -F\t\tFASTA file of all reference sequences. Please make sure this file is the same one provided to BWA-MEM. Either this argument or --ref-dir/-R is required for splicing signal searching.\n";
	print "\t--log or -G\t\t\toutput log file name. (optional)\n";
	print "\t--help or -H\t\t\tshow help information\n";
	print "\t--max-span or -M\t\tmax spanning distance (default: 500000)\n";
	print "\t--high-strigency or -high\tuse high strigency: only output circRNAs supported by more than 2 distinct PCC signals (default)\n";
	print "\t--low-strigency or -low\t\tuse low strigency: only output circRNAs supported by more than 2 junction reads\n";
	print "\t--no-strigency or -0\t\toutput all circRNAs regardless junction read counts or PCC signals\n";
	print "\t--mapq_uni or -U\t\tset threshold for mappqing quality of each segment of junction reads (optional; e.g. 3)\n";
	print "\t--mapq_both or -B\t\tset threshold for mappqing quality sum of two segments of junction reads (optional; e.g. 13)\n";
	print "\t--ident_exon_filter or -E\tset a filter to rule out all possible false positives resulting from identical colinear exon (optional)\n";
	print "\t--ident_exon_dist or -T\t\tset a maximum distance (bp) of a possible identical colinear sequence away from a candidate circRNA on reference (only available when --ident_exon_filter/-E is set; should be larger than 100; default: 100000)\n";
	print "\t--ident_exon_length or -N\tset a minimum length (bp) of a possible identical colinear sequence of a candidate circRNA on reference (only available when --ident_exon_filter/-E is set; should be larger than 20; default: 30)\n";
	print "\t--rel_exp or -RE\t\tset threshold for relative expression calculated based on counts of junction reads and non-junction reads(optional: e.g. 0.1)\n";
	die;
}
my $strigency;
#my $read_length;
my @die_reason;
if(!defined($sam)){
	push @die_reason, "Please use --in or -I option to designate input SAM alignment file!\n";
}elsif(!-e $sam or !-f $sam){
	push @die_reason, "No SAM alignment file found at designated directory!\n";
}

{
	my (%test_read, %read_length_types);
	open SAM, "<", $sam or die "cannot open the sam file: $!";
	while (<SAM>){
		chomp;
		next if /^[@]/;
		my @line = split /\t/;
		if ( !exists($test_read{$line[0]}) ){
			$test_read{$line[0]} = 1;
			$read_length_types{length($line[9])} ++;
		}
		last if scalar(keys %test_read) >= 10;
	}
	unless(scalar(keys %read_length_types) > 1){
		$read_length = $_ for (keys %read_length_types);
	}
}

if(!defined($read_length)){
	push @die_reason, "Please make sure all the reads have the same read lengths!\n";
}elsif($read_length < 40){
	push @die_reason, "Reads length less than 40 is not supported by CIRI!\n";
}elsif($read_length < 60){
	print "Reads length < 60 but >= 40 is supported by CIRI, but read length >= 60 is strongly recommended.\n";
}

if(!defined($cRNA_out)){
	push @die_reason, "Please use --out or -O option to designate output file!\n";
}elsif(-e $cRNA_out and -f $cRNA_out){
	push @die_reason, "Output file $cRNA_out already exists!\n";
}
if( !defined($ref_dir) and !defined($ref_1file) ){
	push @die_reason, "Please use --ref-dir or -R option to designate refenece directory for multiple reference files, or use --ref-file or -F to designate one file with all references in!\n";
}elsif( defined($ref_dir) and (!-e $ref_dir or !-d $ref_dir) ){
	push @die_reason, "Reference directory $ref_dir does not exist!\n";
}elsif( defined($ref_dir) and !-r $ref_dir ){
	push @die_reason, "Reference directory $ref_dir is not readable!\n";
}elsif( defined($ref_1file) and (!-e $ref_1file or !-f $ref_1file) ){
	push @die_reason, "Reference file $ref_1file does not exist!\n";
}elsif( defined($ref_1file) and !-r $ref_1file ){
	push @die_reason, "Reference file $ref_1file is not readable!\n";
}
if (defined $ref_dir){
	$ref_dir = substr($ref_dir, 0, length($ref_dir) - 1) if rindex($ref_dir, "/") == length($ref_dir) - 1;
	my @ref_file = <$ref_dir/*.fa $ref_dir/*.fasta>;
	if(@ref_file == 0){
		push @die_reason, "No fasta file is found in designated refenece directory.\n";
		$if_die = 1;
	}
}
my ($if_PE, $gff, $gtf);
if(defined($PE) and defined($SE)){
	push @die_reason, "Please choose PE mode OR SE mode.\n";
}elsif(defined($SE)){
	print "Single-end reads are supported by CIRI, but paired-end reads are strongly recommended for low FDR.\n";
	$if_PE = 1;
}else{
	$if_PE = 2;
}

if(defined($high) and defined($low)){
	push @die_reason, "Sensitivity cannot be both high and low.\n";
}elsif(defined($low)){
	$strigency = 1;
}elsif(defined($no_strigency)){
	$strigency = 0;
}else{
	$strigency = 2;
}

my $if_anno;
if(defined($anno_gtf) and (!-e $anno_gtf or !-f $anno_gtf)){
	push @die_reason, "No annotation file found at designated directory!\n";
}elsif(defined($anno_gtf) and !($anno_gtf =~ /\.gff/ or $anno_gtf =~ /\.gtf/)){
	push @die_reason, "Please provide .gff or .gtf format as annotation file!\n";
}elsif(defined($anno_gtf) and $anno_gtf =~ /\.gff/){
	$gff = 1;
	$if_anno = 1;
}elsif(defined($anno_gtf) and $anno_gtf =~ /\.gtf/){
	$gtf = 1;
	$if_anno = 1;
}

if($gff == 1){
	my $test_line = 1000;
	my $line_count = 0;
	open ANNO, "<", $anno_gtf or die "cannot open the annotation file: $!";
	while(<ANNO>){
		chomp;
		$line_count ++;
		my @line = split /\t/;
		if ($line[2] eq 'exon'){
			if($line[8] =~ /^Parent=\w+\.\w*.*/){
				$gff ++;
				last;
			}elsif($line[8] =~ /gene=\w+;.*transcript_id=\w+\.*/){
				$gff += 2;
				last;
			}
		}
		if ($line_count >= $test_line and $gff == 1){
			last;
		}
	}
	if ($gff == 1){
		push @die_reason, "The GFF file provided cannot be understood by CIRI! Please refer to manual for details of required GFF formats\n";
	}
}

if(defined($max_circle) and $max_circle < 40){
	push @die_reason, "Max span size on reference cannot be smaller than 40!\n";
}elsif(!defined($max_circle)){
	$max_circle = 500_000;
}
unless(defined($if_gtag)){
	$if_gtag = 1;
}

if(defined($identical_exon_length) and !defined ($identical_exon_filter)){
	push @die_reason, "Please make sure if you wish to use the filter to remove false positives of identical sequence: --ident_exon_filter/-E is required when setting --ident_exon_length/-N.\n";
}if(defined($identical_exon_dist) and !defined ($identical_exon_filter)){
	push @die_reason, "Please make sure if you wish to use the filter to remove false positives of identical sequence: --ident_exon_filter/-E is required when setting --ident_exon_dist/-T.\n";
}if(defined($identical_exon_dist) and $identical_exon_dist < 100){
	push @die_reason, "Please set a maximum distance of identical sequence larger than 100!\n";
}if(defined($identical_exon_length) and $identical_exon_length <= 20){
	push @die_reason, "Please set a minimum of identical sequence larger than 20.\n";
}if(defined ($identical_exon_filter) and !defined($identical_exon_length)){
	$identical_exon_length = 30;
}if(defined ($identical_exon_filter) and !defined($identical_exon_dist)){
	$identical_exon_dist = 100_000;
}

if(defined($rel_exp) and $rel_exp > 1){
	push @die_reason, "Relative expression cannot be larger than 1!\n";
}if(defined($rel_exp) and $rel_exp < 0){
	push @die_reason, "Relative expression cannot be smaller than 0!\n";
}

if (@die_reason >= 1){
	print @die_reason;
	die;
}
if(!defined($log)){
	$log = $cRNA_out.'.log';
}

my ($pre_read, $pre_read2, $strand_2nd, $z2, @candidate_reads, @loci_validated, $total_validated, @qualified_cluster);
my (@PE_reads, @PE_reads2);
my $cluster_num2 = 0;
my ($asterisk, $all_length_match) = (0, 0);
my (%chr, %site1, %site2, %sense_strand, %sense_strand_cluster, %cluster_read, %chr_validated, %chr_end1, %chr_end2, %chr_seq1, %chr_seq2, %seq4read1, %seq4read2, %chr_reads, %chr_cluster, %chr_division1, %chr_division2, %site1_cluster, %site2_cluster, %linear_cp, %FP, %string, %chr_seq_length, %MSID_read, %FP_cluster, %cigar_read, %if_1st_read, %seq1_cluster, %seq2_cluster, %chr_division1_reads, %chr_division2_reads, %chr_range1, %chr_range2, %chr_range1_reads, %chr_range2_reads);
my (%chr_site1_gene_trsc, %chr_site2_gene_trsc);
my (%chr_site1, %chr_site2, %chr_gene_site1, %chr_gene_site2, %chr_site1_gene, %chr_site2_gene);
my $cluster_num = 0;
my %gene_exon_exist;
my (%gene_exon, %gene_loci, %chr_gene, $if_anno_add, %read_anno, %cluster_anno, %anno_gene, %anno_cluster);	#%exon_read, %intron_read, %exon_cluster, %intron_cluster, %inter_gene_cluster
my $add_validated;
my ($inter_num, $intron_num, $exon_num);
my %type;
my %candidate4mode_check;
my %read_in_chr;
#my ($mapq_uni, $mapq_both) = (3, 13);
open CRNAOUT, ">>", $cRNA_out or die;
open SAM, "<", $sam or die "cannot open the sam file: $!";
open MOD, ">>", $log or die;
print MOD scalar(localtime),"\n";
print MOD "First scanning starts...\n";
print "First scanning starts...\n";
#print MOD "$?\n";
while(<SAM>){
	chomp;
	my @line = split (/\t/, $_, 2);
	my $read_name;
	if($line[0] =~ m%^(.+)/[12]$% or $line[0] =~ m%^(.+)_[12]$%){
		$read_name = $1;
	}else{
		$read_name = $line[0];
	}
	if($pre_read ne $read_name){
		&mapping_check1(@PE_reads) if @PE_reads > $if_PE;						## sub mapping_check1
		@PE_reads = ();
	}
	push @PE_reads, $_;
	$pre_read = $read_name;
}
if($if_anno == 1 and $gtf == 1){
	my $pre_gene;
	open ANNO, "<", $anno_gtf or die "cannot open the annotation file: $!";
	while(<ANNO>){
		chomp;
		my @line = split /\t/;
		if ($line[2] eq 'exon'){
			my @atr = split '; ', $line[8];
			$atr[0] =~ /gene_id \"(.+)\"/;
			my $gene_ID = $1;
			if($pre_gene ne $gene_ID and $pre_gene ne ''){
				&split_transcript($pre_gene, @gene_anno);
				@gene_anno = ();
			}
			push @gene_anno, $_;
			$pre_gene = $gene_ID;
		}
	}
	&split_transcript($pre_gene, @gene_anno);
}elsif($if_anno == 1 and $gff >= 2){
	my $pre_gene;
	if ($gff == 2){
		open ANNO, "<", $anno_gtf or die "cannot open the annotation file: $!";
		while(<ANNO>){
			chomp;
			my @line = split /\t/;
			if ($line[2] eq 'exon'){
				$line[8] =~ /^Parent=((\w+)\.\w*).*/;
				my $gene_ID = $2;
				if($pre_gene ne $gene_ID and $pre_gene ne ''){
					&split_transcript($pre_gene, @gene_anno);
					@gene_anno = ();
				}
				push @gene_anno, $_;
				$pre_gene = $gene_ID;
			}
		}
		&split_transcript($pre_gene, @gene_anno);
	}elsif($gff == 3){
		open ANNO, "<", $anno_gtf or die "cannot open the annotation file: $!";
		while(<ANNO>){
			chomp;
			my @line = split /\t/;
			if ($line[2] eq 'exon'){
				$line[8] =~ /;gene=(\w+)/;
				my $gene_ID = $1;
				if($pre_gene ne $gene_ID and $pre_gene ne ''){
					&split_transcript($pre_gene, @gene_anno);
					@gene_anno = ();
				}
				push @gene_anno, $_;
				$pre_gene = $gene_ID;
			}
		}
		&split_transcript($pre_gene, @gene_anno);
	}
}
print MOD "Candidate reads of circular RNA: ".scalar(@candidate_reads)."\n";
print "Candidate reads of circular RNA: ".scalar(@candidate_reads)."\n";
print MOD "Splicing signals checking starts...\n";
print "Splicing signals checking starts...\n";
&splice_loci_check(@candidate_reads);
print MOD "Candidate reads with splicing signals: ".scalar(@loci_validated)."\n";
print "Candidate reads with splicing signals: ".scalar(@loci_validated)."\n";
print MOD "Clustering starts...\n";
print "Clustering starts...\n";
&cluster_reads(@loci_validated);
print MOD "$cluster_num clusters\n";
print "$cluster_num clusters\n";
print MOD "Second scanning starts...\n";
print "Second scanning starts...\n";
open SAM, "<", $sam or die "cannot open the sam file: $!";
LINE: while(<SAM>){
	chomp;
	my @line = split /\t/;
	#print "$line[0]\n";
	my ($pinhead, $pinhead2) = (0, 0);
	my $chr_div;
	my (@str, @str_comp, @bingo, $read_name, @lt5);
	if($line[0] =~ m%^(.+)/[12]$% or $line[0] =~ m%^(.+)_[12]$%){
		$read_name = $1;
	}else{
		$read_name = $line[0];
	}
	my $ten2b5 = &ten2b($line[1], 5);
	my $ten2b7 = &ten2b($line[1], 7);
	if(($pre_read2 ne $read_name or $strand_2nd != $ten2b7) and length($line[9]) == $read_length and &ten2b($line[1], 3) == 0){
		$seq_2nd = $line[9];
		$z2 = $ten2b5;
		$strand_2nd = $ten2b7;
		$pre_read2 = $read_name;
	}
	if ($line[5] eq '*'){
		next;
	}elsif ($line[5] eq "${read_length}M"){
		my $division1 = int($line[3]/500);
		for my $i($division1 .. $division1+1){
			my $chr_div = "$line[2]:$i";
			for my $j( @{$chr_division1{$chr_div}} ){
				if($line[3] <= $site1_cluster{$j}-6 and $line[3]+$read_length-1>=$site1_cluster{$j}+6){
					push @{$linear_cp{$j}}, $read_name;
				}
			}
			for my $j( @{$chr_division2{$chr_div}} ){
				if($line[3] <= $site2_cluster{$j}-6 and $line[3]+$read_length-1>=$site2_cluster{$j}+6){
					push @{$linear_cp{$j}}, $read_name;
				}
			}
		}
	}else{
		if($z2 != $ten2b5){
			$seq_2nd = &comp_rev($seq_2nd);
			$z2 = $ten2b5;
		}
		my $MSID = &MSID($line[5]);
		my @msid;
		if(abs($$MSID[0])==1){
			if ($$MSID[0] == -1 and $$MSID[1] >= 5){
				$chr_div = "$line[2]:$line[3]";
				#print "$chr_div\n";
				for my $clusterID( @{$chr_range1{$chr_div}} ){
					my $distance1 = $line[3] - $site1_cluster{ $clusterID };
					push @str, substr($seq_2nd, 0, $$MSID[1]-$distance1);
					push @str_comp, $seq1_cluster{$clusterID};
					$pinhead = 1;
					push @bingo, $clusterID;
				}
			}elsif($$MSID[0] == 1 and $$MSID[1] <= $read_length - 5){
				$chr_div = "$line[2]:".($line[3]+$$MSID[-1]-1);
				#print "$chr_div\n";
				for my $clusterID( @{$chr_range2{$chr_div}} ){
					my $distance1 = $line[3]+$$MSID[-1]-1 - $site2_cluster{ $clusterID };
					push @str, substr($seq_2nd, $$MSID[1] - $distance1);
					push @str_comp, $seq2_cluster{$clusterID};
					$pinhead = 2;
					push @bingo, $clusterID;
				}
			}
		}elsif($$MSID[0] == 10){
			$chr_div = "$line[2]:$line[3]";
			for my $clusterID( @{$chr_range1{$chr_div}} ){
				my $distance1 = $line[3] - $site1_cluster{ $clusterID };
				push @str, substr($seq_2nd, 0, $$MSID[1]-$distance1);
				push @str_comp, $seq1_cluster{$clusterID};
				$pinhead = 3;
				push @bingo, $clusterID;
				push @msid, -1;
			}
			$chr_div = "$line[2]:".($line[3]+$$MSID[-1]-1);
			for my $clusterID( @{$chr_range2{$chr_div}} ){
				my $distance1 = $line[3]+$$MSID[-1]-1 - $site2_cluster{ $clusterID };
				push @str, substr($seq_2nd, $read_length-$$MSID[2]-$distance1);
				push @str_comp, $seq2_cluster{$clusterID};
				$pinhead = 4;
				push @bingo, $clusterID;
				push @msid, 1;
			}
		}
		if ($pinhead > 0){
			#print "$pinhead\n";
			#print "@bingo\n" if ($line[0] eq 'simulate:2087907');
			for my $x(0 .. $#bingo){
				#print "$bingo[$x]\t$str[$x]\t$str_comp[$x]\t$$MSID[0]\t$site1_cluster{$bingo[$x]}\t$site2_cluster{$bingo[$x]}\t$seq1_cluster{$bingo[$x]}\t$seq2_cluster{$bingo[$x]}\n" if ($line[0] eq 'simulate:2087907');
				#print &DP_alignment($$MSID[0], $str[$x], $str_comp[$x]), "\n" if ($line[0] eq 'simulate:2087907');
				if( length($str[$x]) >= 5 ){
					next unless length($str_comp[$x]) >= 5;
					if( ( $pinhead <= 2 and &DP_alignment($$MSID[0], $str[$x], $str_comp[$x]) ) or ( $pinhead >=3 and &DP_alignment($msid[$x], $str[$x], $str_comp[$x]) ) ){
						#print "x1\n" if ($line[0] eq 'simulate:2087907');
						$pinhead2 = 1;
						unless ( $read_name ~~ @{ $bingo[$x] } ){
							$pinhead2 = 2;
							push @allreadTBD, $read_name;
							$PE_end{$read_name} = $ten2b7;
							$chr{$read_name} = $line[2];
							$site1{$read_name} = $site1_cluster{$bingo[$x]};
							$site2{$read_name} = $site2_cluster{$bingo[$x]};
							$strand{$read_name} = $ten2b5;
							$MSID_read{$read_name} = $MSID;
							$possible_cluster{$read_name} = $bingo[$x];
							$string_length{$read_name} = [ length( $seq1_cluster{$bingo[$x]} ), length( $seq2_cluster{$bingo[$x]} ) ];
							if($pinhead == 1 or $pinhead == 3){
								${$cigar_read{$read_name}}[0] = $line[5];
							}elsif($pinhead == 2 or $pinhead == 4){
								${$cigar_read{$read_name}}[1] = $line[5];
							}else{
								${$cigar_read{$read_name}}[2] = $line[5];
							}
						}
					}
				}else{
					push @lt5, $x;
				}
			}
			#print "$pinhead2\n" if ($line[0] eq 'simulate:2087907');
			if($pinhead2 == 0){
				#print "y1\n" if ($line[0] eq 'simulate:2087907');
				for my $x(0 .. $#bingo){
					#print "$bingo[$x]\n" if ($line[0] eq 'simulate:2087907');
					unless ($x ~~ @lt5){
						#print "y2\n" if ($line[0] eq 'simulate:2087907');
						push @{ $linear_cp{ $bingo[$x] } }, $read_name;
					}
				}
			}
		}else{
			my $division1 = int($line[3]/500);
			#print "$division1\n";
			for my $i($division1 .. $division1+1){
				my $chr_div = "$line[2]:$i";
				for my $j( @{$chr_division1{$chr_div}} ){
					if($line[3] <= $site1_cluster{$j}-6 and $line[3]+$$MSID[-1]-1>=$site1_cluster{$j}+6){
						push @{$linear_cp{$j}}, $read_name;
					}
				}
				for my $j( @{$chr_division2{$chr_div}} ){
					if($line[3] <= $site2_cluster{$j}-6 and $line[3]+$$MSID[-1]-1>=$site2_cluster{$j}+6){
						push @{$linear_cp{$j}}, $read_name;
					}
				}
			}
		}
	}
}
print MOD "Additional candidate reads found: ".scalar(@allreadTBD)."\n";
print "Additional candidate reads found: ".scalar(@allreadTBD)."\n";
open SAM, $sam or die "cannot open the sam file: $!";
while(<SAM>){
	chomp;
	my $read_name;
	my @line = split /\t/;
	if($line[0] =~ m%^(.+)/[12]$% or $line[0] =~ m%^(.+)_[12]$%){
		$read_name = $1;
	}else{
		$read_name = $line[0];
	}
	if(exists $PE_end{$read_name}){
		my $strand = &ten2b($line[1], 5);
		if($PE_end{$read_name} != &ten2b($line[1], 7)){
			if($line[2] eq $chr{$read_name} and $strand != $strand{$read_name}){
				my $MSID = &MSID($line[5]);
				if($line[3] >= $site1{$read_name} - 6 and $line[3] + $$MSID[-1] - 1 <= $site2{$read_name} + 6){
					unless ($read_name ~~ @{$possible_cluster{$read_name}}){
						push @{$possible_cluster{$read_name}}, $read_name;
						$add_validated++;
					}
				}
			}
		}else{
			push @{$possible_cluster{$read_name}}, $read_name unless ($read_name ~~ @{$possible_cluster{$read_name}} or $if_PE == 2);
			my $MSID = &MSID($line[5]);
			if($$MSID[0] == -1){
				if(${$MSID_read{$read_name}}[0] == 1 and $chr{$read_name} eq $line[2] and $strand{$read_name} == $strand and abs($$MSID[1] - ${$MSID_read{$read_name}}[1]) <= 6 and abs($site1{$read_name}-$line[3])>6){
					$FP{$read_name} ++;
					if($$MSID[-1]>=${$string_length{$read_name}}[1]){
						$FP{$read_name} += 10;
					}
				}
			}elsif($$MSID[0] == 1){
				if(${$MSID_read{$read_name}}[0] == -1 and $chr{$read_name} eq $line[2] and $strand{$read_name} == $strand and abs($$MSID[1] - ${$MSID_read{$read_name}}[1]) <= 6 and abs($site2{$read_name}-$line[3]-$$MSID[-1]+1)>6){
					$FP{$read_name} ++;
					if($$MSID[-1]>=${$string_length{$read_name}}[0]){						
						$FP{$read_name} += 10;
					}
				}
			}elsif($$MSID[0] == 10 and $chr{$read_name} eq $line[2]){
				if(${$MSID_read{$read_name}}[0] == -1 and $strand{$read_name} == $strand and abs($read_length-$$MSID[2]-${$MSID_read{$read_name}}[1])<=6 and abs($site2{$read_name}-$line[3]-$$MSID[-1]+1)>6){
					$FP{$read_name} ++;
					if($$MSID[-1]>=${$string_length{$read_name}}[0]){
						$FP{$read_name} += 10;
					}
				}elsif(${$MSID_read{$read_name}}[0] == 1 and $strand{$read_name} == $strand and abs($$MSID[1]-${$MSID_read{$read_name}}[1])<=6 and abs($site1{$read_name}-$line[3])>6){
					$FP{$read_name} ++;
					if($$MSID[-1]>=${$string_length{$read_name}}[1]){
						$FP{$read_name} += 10;
					}
				}
			}
		}
	}
}
if ($if_PE == 2){
	print MOD "Additional candidate reads with PEM signals: $add_validated\n";
	print "Additional candidate reads with PEM signals: $add_validated\n";
}
print MOD "Summarizing starts...\n";
print "Summarizing starts...\n";


	for $j(0 .. $cluster_num-1){
		my $clusterID = 'cluster'.$j;
		my (@FP_reads, @FP_reads2, @TP_reads);
		my %cigar_cluster;

		for (@$clusterID){
			if($FP{$_} > 10){
				push @FP_reads2, $_;
				$FP_cluster{$clusterID} = 1;
			}elsif($FP{$_} >= 1){
				push @FP_reads, $_;
			}else{
				push @TP_reads, $_;
				for my $n(0 .. 2){
					push @{$cigar_cluster{$n}}, ${$cigar_read{$_}}[$n] unless (!defined ${$cigar_read{$_}}[$n] or ${$cigar_read{$_}}[$n] ~~ @{$cigar_cluster{$n}});
				}
			}
		}
		my %CIGAR_count;
		for my $cigar_position(0 .. 2){
			if(@{$cigar_cluster{$cigar_position}} > 0){
				$CIGAR_count{$cigar_position} = scalar(@{$cigar_cluster{$cigar_position}});
			}else{
				$CIGAR_count{$cigar_position} = 0;
			}
		}
		if($strigency == 2 and @FP_reads2 == 0 and @TP_reads > @FP_reads and @TP_reads > 0 and $CIGAR_count{"0"}+$CIGAR_count{"1"}+$CIGAR_count{"2"}>=3){
			$cluster_num2 ++;
			$final_cluster{$cluster_num2} = $clusterID;
			#$cigars_cluster{$clusterID} = @{$cigar_cluster{"0"}}."_".@{$cigar_cluster{"1"}}."_".@{$cigar_cluster{"2"}};
			$cigars_cluster{$clusterID} = $CIGAR_count{"0"}."_".$CIGAR_count{"1"}."_".$CIGAR_count{"2"};
			$exp_cRNA{$clusterID} = \@TP_reads;
		}elsif($strigency == 1 and @FP_reads2 == 0 and @TP_reads > @FP_reads and @TP_reads >= 2){
			$cluster_num2 ++;
			$final_cluster{$cluster_num2} = $clusterID;
			#$cigars_cluster{$clusterID} = @{$cigar_cluster{"0"}}."_".@{$cigar_cluster{"1"}}."_".@{$cigar_cluster{"2"}};
			$cigars_cluster{$clusterID} = $CIGAR_count{"0"}."_".$CIGAR_count{"1"}."_".$CIGAR_count{"2"};
			$exp_cRNA{$clusterID} = \@TP_reads;
		}elsif($strigency == 0 and @FP_reads2 == 0 and @TP_reads > @FP_reads){
			$cluster_num2 ++;
			$final_cluster{$cluster_num2} = $clusterID;
			#$cigars_cluster{$clusterID} = @{$cigar_cluster{"0"}}."_".@{$cigar_cluster{"1"}}."_".@{$cigar_cluster{"2"}};
			$cigars_cluster{$clusterID} = $CIGAR_count{"0"}."_".$CIGAR_count{"1"}."_".$CIGAR_count{"2"};
			$exp_cRNA{$clusterID} = \@TP_reads;
		}

	}
my ($removed4rel_exp) = (0);
if ($if_anno == 1){
	print CRNAOUT "circRNA_ID\tchr\tcircRNA_start\tcircRNA_end\t#junction_reads\tSM_MS_SMS\t#non_junction_reads\tjunction_reads_ratio\tcircRNA_type\tgene_id\tjunction_reads_ID\n";
	for my $i(1 .. $cluster_num2){
		my $clusterID = $final_cluster{$i};
		if (defined($rel_exp) and @{ $exp_cRNA{$clusterID} } < @{$linear_cp{$clusterID}}*$rel_exp/2){
			$removed4rel_exp ++;
			next;
		}
		printf CRNAOUT "$chr_cluster{$clusterID}:$site1_cluster{$clusterID}|$site2_cluster{$clusterID}\t$chr_cluster{$clusterID}\t$site1_cluster{$clusterID}\t$site2_cluster{$clusterID}\t".scalar(@{$exp_cRNA{$clusterID}})."\t$cigars_cluster{$clusterID}\t".scalar(@{$linear_cp{$clusterID}})."\t%.3f", (@{ $exp_cRNA{$clusterID} }/( @{$linear_cp{$clusterID}}/2 + @{$exp_cRNA{$clusterID}} ));
		if($cluster_anno{$clusterID} eq 'exon'){
			$exon_num++;
			print CRNAOUT "\texon\t$anno_cluster{$clusterID}\t";
			print CRNAOUT "$_," for @{$exp_cRNA{$clusterID}};
			print CRNAOUT "\n";
		}elsif($cluster_anno{$clusterID} eq 'intron'){
			$intron_num++;
			print CRNAOUT "\tintron\t@{$anno_cluster{$clusterID}}\t";
			print CRNAOUT "$_," for @{$exp_cRNA{$clusterID}};
			print CRNAOUT "\n";
		}elsif($cluster_anno{$clusterID} eq 'intergenic'){
			$inter_num++;
			print CRNAOUT "\tintergenic region\tn/a\t";
			print CRNAOUT "$_," for @{$exp_cRNA{$clusterID}};
			print CRNAOUT "\n";
		}
	}
}else{
	print CRNAOUT "circRNA_ID\tchr\tcircRNA_start\tcircRNA_end\t#junction_reads\tSM_MS_SMS\t#non_junction_reads\tjunction_reads_ratio\tcircRNA_type\tgene_id\tjunction_reads_ID\n";
	for my $i(1 .. $cluster_num2){
		my $clusterID = $final_cluster{$i};
		if (defined($rel_exp) and @{ $exp_cRNA{$clusterID} } < @{$linear_cp{$clusterID}}*$rel_exp/2){
			$removed4rel_exp ++;
			next;
		}
		printf CRNAOUT "$chr_cluster{$clusterID}:$site1_cluster{$clusterID}|$site2_cluster{$clusterID}\t$chr_cluster{$clusterID}\t$site1_cluster{$clusterID}\t$site2_cluster{$clusterID}\t".scalar(@{$exp_cRNA{$clusterID}})."\t$cigars_cluster{$clusterID}\t".scalar(@{$linear_cp{$clusterID}})."\t%.3f\tn/a\t/n/a\t", (@{ $exp_cRNA{$clusterID} }/( @{$linear_cp{$clusterID}}/2 + @{$exp_cRNA{$clusterID}} ));
		print CRNAOUT "$_," for @{$exp_cRNA{$clusterID}};
		print CRNAOUT "\n";
	}
}
my $timeB = time;
print MOD scalar(localtime),"\n";
printf MOD "Running time: %.1f hour(s)\n", ($timeB-$timeA)/3600;
print "Number of putative circular RNAs found: ", ($cluster_num2-$removed4rel_exp), ". Please see output file $cRNA_out for detail.\n";
print MOD "Number of putative circular RNAs found: ", ($cluster_num2-$removed4rel_exp), "\n";
print MOD "intergenic region: $inter_num\nintron region: $intron_num\nexon region: $exon_num\ntotal: ", ($cluster_num2-$removed4rel_exp), "\n" if $if_anno == 1;
print MOD "-" x 50, "\n";
sub split_transcript{
	my $gene = shift @_;
	my @line2 = split (/\t/, $_[0]);
	my $chr = $line2[0];
	my $initial_site = $line2[3];
	@line2 = split (/\t/, $_[-1]);
	my $final_site = $line2[4];
	for (@_){
		my @line = split /\t/;
		unless (exists $gene_exon_exist{$gene.":".$line[3].":".$line[4]}){
			push @{ $gene_exon{ $chr.":".$gene } }, [ $line[3], $line[4] ];
			$gene_exon_exist{$gene.":".$line[3].":".$line[4]} = 1;
			$initial_site = $line[3] if $line[3] < $initial_site;
			$final_site = $line[4] if $line[4] > $final_site;
		}
	}
	if(exists $gene_loci{$chr.":".$gene}){
		$gene_loci{$chr.":".$gene}[0] = $initial_site if $gene_loci{$chr.":".$gene}[0] > $initial_site;
		$gene_loci{$chr.":".$gene}[1] = $final_site if $gene_loci{$chr.":".$gene}[1] < $final_site;
	}else{
		push @{$chr_gene{ $chr }}, $gene;
		$gene_loci{$chr.":".$gene} = [ $initial_site, $final_site ];
	}
	#print MOD "$gene\t$initial_site\t$final_site\n";
}

sub DP_alignment{
	my (@score_list, %score);
	my $mode = shift @_;
	my($sequence1, $sequence2) = sort {length($b) <=> length($a)} @_;
	if($mode == -1){
		$sequence1 = substr($sequence1, length($sequence1)-length($sequence2));
	}else{
		$sequence1 = substr($sequence1, 0, length($sequence2));
	}
	my @seq1 = split "", $sequence1;
	my @seq2 = split "", $sequence2;
	for my $i(0 .. $#seq1){
		if ($i == 0){
			for(@seq2){
				#print OUT "\t$_";
			}
		}
		for my $j(0 .. $#seq2){
			#print OUT "\n$seq1[$i]\t" if $j == 0;
			if ($seq1[$i] eq $seq2[$j]){
				@score_list = sort{$b <=> $a} ($score{$i, $j-1}-4, $score{$i-1, $j}-4, $score{$i-1, $j-1}+1);
				$score{$i, $j} = $score_list[0];
			}else{
				@score_list = sort{$b <=> $a} ($score{$i, $j-1}-4, $score{$i-1, $j}-4, $score{$i-1, $j-1}-3);
				$score{$i, $j} = $score_list[0];
			}
			#print OUT "$score{$i, $j}\t";
		}
	}
	#print OUT "\n";
	if ($score{$#seq1, $#seq2}/length($sequence2) >= 0.7){
		1;
	}else{
		0;
	}
}
sub cluster_reads{
	my $pre;
	my @sort_reads1 = sort {$chr{$a} cmp $chr{$b} or $site1{$a} <=> $site1{$b}} @_;
	my %group_read;
	my $group_num = 0;
	for (@sort_reads1){
		if ( $site1{$_} - $site1{$pre} <= 3 and $chr{$_} eq $chr{$pre}){
			push @{$group_read{$pre}}, $_;
			$group_read{$_} = $group_read{$pre};
		}else{
			my $group_ID = 'group'.$group_num;
			$group_read{$_} = $group_ID;
			push @$group_ID, $_;
			$group_num++;
		}
		$pre = $_;
	}
	for my $i(0 .. $group_num-1){
		my $group_ID = 'group'.$i;
		my @sort_reads2 = sort {$site2{$a} <=> $site2{$b}} @$group_ID;
		my $pre2;
		for (@sort_reads2){
			if ( $site2{$_} - $site2{$pre2} <= 3 ){
				push @{$cluster_read{$pre2}}, $_;
				$cluster_read{$_} = $cluster_read{$pre2};
			}else{
				my $clusterID = 'cluster'. $cluster_num;
				$cluster_read{$_} = $clusterID;
				push @$clusterID, $_;
				$cluster_num++;
				$chr_cluster{$clusterID} = $chr{$_};
			}
			$pre2 = $_;
		}
	}
	for my $j(0 .. $cluster_num-1){
		my $clusterID = 'cluster'.$j;
		my $x = int($#$clusterID/2);
		my $chromo = $chr_cluster{$clusterID};
		$if_anno_add_cluster{$clusterID}=1 if exists $if_anno_add{$$clusterID[$x]};
		if($read_anno{$$clusterID[$x]} eq 'exon'){
			$cluster_anno{$clusterID}= 'exon';
			$anno_cluster{$clusterID}=$anno_gene{$$clusterID[$x]};
		}elsif($read_anno{$$clusterID[$x]} eq 'intron'){
			$cluster_anno{$clusterID}= 'intron';
			$anno_cluster{$clusterID}=$anno_gene{$$clusterID[$x]};
		}else{
			$cluster_anno{$clusterID}='intergenic';
		}
		push @{$chr_reads{$chromo}}, $_ for @$clusterID;
		@clusterID2 = sort {length($seq4read1{$b}) <=> length($seq4read1{$a})} @$clusterID;
		@clusterID3 = sort {length($seq4read2{$b}) <=> length($seq4read2{$a})} @$clusterID;
		$site1_cluster{$clusterID} = $site1{$$clusterID[$x]};
		$site2_cluster{$clusterID} = $site2{$$clusterID[$x]};
		$sense_strand_cluster{$clusterID} = $sense_strand{$$clusterID[$x]};
		my $division1 = int($site1_cluster{$clusterID}/500);	#added
		my $division2 = int($site2_cluster{$clusterID}/500);	#added
		for (-6 .. 6){
			my $range1 = "$chromo:".( $site1_cluster{$clusterID}+$_ );
			my $range2 = "$chromo:".( $site2_cluster{$clusterID}+$_ );
			push @{$chr_range1{ $range1 }}, $clusterID;			#added
			push @{$chr_range2{ $range2 }}, $clusterID;
		}
		push @{$chr_division1{ "$chromo:$division1" }}, $clusterID;			#added
		push @{$chr_division2{ "$chromo:$division2" }}, $clusterID;
		if($if_gtag == 0){
			my $diff_adjt = $site1_cluster{$clusterID} - $site1{$clusterID2[0]};
			my $adjt_seq;
			if ($diff_adjt > 0){
				$adjt_seq = substr($seq4read2{ $clusterID2[0] }, 0, $diff_adjt);
				$seq1_cluster{$clusterID} = $seq4read1{ $clusterID2[0] }.$adjt_seq;
			}elsif($diff_adjt <= 0){
				$seq1_cluster{$clusterID} = substr($seq4read1{ $clusterID2[0] }, 0, length($seq4read1{ $clusterID2[0] })+$diff_adjt);
			}
			my $diff_adjt2 = $site2_cluster{$clusterID} - $site2{$clusterID3[0]};
			my $adjt_seq2;
			if ($diff_adjt2 >= 0){
				$seq2_cluster{$clusterID} = substr($seq4read2{ $clusterID3[0] }, $diff_adjt2);
			}elsif($diff_adjt2 < 0){
				$adjt_seq2 = substr( $seq4read1{ $clusterID3[0] }, length($seq4read1{ $clusterID3[0] })+$diff_adjt2 );
				$seq2_cluster{$clusterID} = $adjt_seq2.$seq4read2{ $clusterID3[0] };	
			}
		}else{
			$seq1_cluster{$clusterID} = $seq4read1{ $clusterID2[0] };
			$seq2_cluster{$clusterID} = $seq4read2{ $clusterID3[0] };	
		}
		$type{$clusterID} = $candidate4mode_check{$$clusterID[$x]};
	}
}
sub sort_genes_in_chr{
	my (%gene_group, %group_ends, %group_mem);
	my @output;
	my @ends;
	my $chr = shift @_;
	my @sort_genes = sort { $gene_loci{$chr.":".$a}[0] <=> $gene_loci{$chr.":".$b}[0] or $gene_loci{$chr.":".$b}[1] <=> $gene_loci{$chr.":".$a}[1] } @{$chr_gene{ $chr }};
	$gene_group{$sort_genes[0]} = "gene_group1";
	$group_ends{"gene_group1"} = [ $gene_loci{$chr.":".$sort_genes[0]}[0], $gene_loci{$chr.":".$sort_genes[0]}[1] ];
	$group_mem{"gene_group1"} = [ $sort_genes[0] ];
	my $group_gene_num = 1;
	for my $x(1 .. $#sort_genes){
		my $gene1 = $sort_genes[$x-1];
		my $gene2 = $sort_genes[$x];
		if ( $gene_loci{$chr.":".$gene2}[0] < ${ $group_ends{$gene_group{$gene1}} }[1] ){
			push @{$group_mem{$gene_group{$gene1}}}, $gene2;
			$gene_group{$gene2} = $gene_group{$gene1};
			${ $group_ends{$gene_group{$gene1}} }[1] = $gene_loci{$chr.":".$gene2}[1] if $gene_loci{$chr.":".$gene2}[1] > ${ $group_ends{$gene_group{$gene1}} }[1];
		}else{
			$group_gene_num ++;
			$gene_group{$gene2} = "gene_group".$group_gene_num;
			$group_ends{"gene_group".$group_gene_num} = [ $gene_loci{$chr.":".$gene2}[0], $gene_loci{$chr.":".$gene2}[1] ];
			$group_mem{"gene_group".$group_gene_num} = [$gene2];
		}
	}
	for my $j(1 .. $group_gene_num){
		push @output, $group_mem{"gene_group".$j};
		push @ends, $group_ends{"gene_group".$j};
	}
	(\@output, \@ends);
}
sub splice_loci_check{
	my @chr_type;
	my ($positive_num1, $positive_num2);
	my @sort_reads = sort {$chr{$a} cmp $chr{$b}} @_;
	for my $read(@sort_reads){
		push @chr_type, $chr{$read} unless $chr{$read} eq $chr_type[-1];
		#my $read_in_chr = "read_in".$chr{$read};
		#push @$read_in_chr, $read;
		push @{ $read_in_chr{$chr{$read}} }, $read;
	}
	if(defined $ref_dir){
		for my $chr(@chr_type){
			if($if_gtag == 2){
				#my $read_in_chr = "read_in".$chr;
				for (@{$read_in_chr{$chr}}){
					$candidate4mode_check{$_} = 1;
				}
			}else{
				open CHR, "<", $ref_dir."/".$chr.".fa" or open CHR, "<", $ref_dir."/".$chr.".fasta" or die "cannot open chromosome file of $chr in directory $ref_dir: $!";
				my $chr_seq;
				my $uni_seq = 0;
				while(<CHR>){
					chomp;
					if(/^>/ and $uni_seq == 0){
						$uni_seq = 1;
					}elsif(/^>/){
						die "There are more than one sequence in $chr file. Please check!";
					}else{
						$chr_seq .= $_;
					}
				}
				#my $read_in_chr = "read_in".$chr;
				for (@{$read_in_chr{$chr}}){
					push @loci_validated, $_ if $if_gtag == 0;
					my ($end_string1, $end_string2);
					my $ori_site1 = $site1{$_}-$end_adjt1{$_};
					my $ori_site2 = $site2{$_}-$end_adjt2{$_};
					my $diff_adjt;
					my $pinhead = 0;
					my $total_adjustment = $end_adjt1{$_} + $end_adjt2{$_};
					if($end_adjt2{$_} >= 0){				
						$end_string1 = substr($chr_seq, $site1{$_}-$end_adjt1{$_}-4, 4+$end_adjt1{$_}+$end_adjt2{$_});
						$end_string2 = substr($chr_seq, $site2{$_}-$end_adjt1{$_}-1, 4+$end_adjt1{$_}+$end_adjt2{$_});
					}else{
						$end_string1 = substr($chr_seq, $site1{$_}+$end_adjt2{$_}-4, 4-$end_adjt1{$_}-$end_adjt2{$_});
						$end_string2 = substr($chr_seq, $site2{$_}+$end_adjt2{$_}-1, 4-$end_adjt1{$_}-$end_adjt2{$_});
					}
					my @index_compare_result = &index_compare($end_string1, $end_string2);
					if ( $index_compare_result[0] != 0 ){
						if ($index_compare_result[0] > 0){
							$positive_num1 ++;
							$sense_strand{$_} = $index_compare_result[2];
						}else{
							$positive_num2 ++;
							$sense_strand{$_} = $index_compare_result[2];
						}
						if($end_adjt2{$_} >= 0){
							$diff_adjt = $index_compare_result[1] - 1 - $end_adjt1{$_};
						}else{
							$diff_adjt = $index_compare_result[1] - 1 + $total_adjustment - $end_adjt1{$_};
						}
						push @loci_validated, $_ if $if_gtag != 0;
						$pinhead = 1;
					}else{
						$candidate4mode_check{$_} = 1;
					}
					if($pinhead == 1){
						$end_adjt1{$_} = $diff_adjt+$end_adjt1{$_};
						$end_adjt2{$_} = $total_adjustment - $end_adjt1{$_};
						$site1{$_} = $site1{$_}+$diff_adjt;
						$site2{$_} = $site2{$_}+$diff_adjt;
						if($diff_adjt > 0){
							my $str_adjustment = substr($seq4read2{$_}, 0, abs($diff_adjt));
							$seq4read1{$_} = $seq4read1{$_}.$str_adjustment;
							$seq4read2{$_} = substr($seq4read2{$_}, abs($diff_adjt));
						}elsif($diff_adjt < 0){
							my $str_adjustment = substr($seq4read1{$_}, length($seq4read1{$_}) - abs($diff_adjt));
							$seq4read2{$_} = $str_adjustment.$seq4read2{$_};
							$seq4read1{$_} = substr($seq4read1{$_}, 0, length($seq4read1{$_}) - abs($diff_adjt));
						}
						###check for identical exon
						if($if_gtag !=0 and defined $identical_exon_filter and $_ eq $loci_validated[-1]){
							my $if_identical_exon = &check_identical_exon($site1{$_}, $site2{$_}, $chr_seq, $chr);
							pop @loci_validated if $if_identical_exon > 0;
						}
					}
				}
			}
			if($if_anno == 1){
				@{$read_in_chr{$chr}} = sort { $site1{$a} <=> $site1{$b} or $site2{$a} <=> $site2{$b} } @{$read_in_chr{$chr}};
				my @genes_annotated = &sort_genes_in_chr( $chr );
				my @genes_group = @{$genes_annotated[0]};
				my @genes_group_ends = @{$genes_annotated[1]};
				my $j = 0;
				READ: for (@{$read_in_chr{$chr}}){
					for my $i( $j .. $#genes_group ){
						my @genes = @{$genes_group[$i]};
						my ($lociA, $lociB) = @{$genes_group_ends[$i]};
						if ( $lociA-6 <= $site1{$_} and $lociB+6 >= $site2{$_} ) {
							$j = $i;
							my @if_passed = ();
							for my $gene (@genes){
								my $loci1 = $gene_loci{$chr.":".$gene}[0];
								my $loci2 = $gene_loci{$chr.":".$gene}[1];
								my $pinhead;
								if ( $loci1-6 <= $site1{$_} and $loci2+6 >= $site2{$_} ) {
									my ($distance1, $distance2, $distance3, $distance4);
									#my $z;
									for my $x( 0 .. $#{$gene_exon{$chr.":".$gene}} ){
										$distance1 = $site1{$_} - $gene_exon{$chr.":".$gene}[$x][0];
										$distance3 = $site1{$_} - $gene_exon{$chr.":".$gene}[$x][1] + 6;
										if ( abs($distance1) <= 6 ){
											$pinhead = 1;
											#$z = $x;
											last;
										}elsif($distance1 > 6 and $distance3 <= 0){
											$pinhead = 3;
											#$z = $x;
											last;
										}
									}
									#if($pinhead == 1 or $pinhead == 3){
										for my $y( 0 .. $#{$gene_exon{$chr.":".$gene}} ){
											$distance2 = $site2{$_} - $gene_exon{$chr.":".$gene}[$y][1];
											$distance4 = $site2{$_} - $gene_exon{$chr.":".$gene}[$y][0] - 6;
											if ( abs($distance2) <= 6 ){
												$pinhead += 1;
												last;
											}elsif($distance2 < -6 and $distance4 >= 0){
												$pinhead += 3;
												last;
											}
										}
										if($pinhead == 2){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if(exists $candidate4mode_check{$_} and $distance1 == $distance2){
												$site1{$_} = $site1{$_} - $distance1;
												$site2{$_} = $site2{$_} - $distance2;
												if($distance1>0){
													my $str_adjustment = substr($seq4read1{$_}, length($seq4read1{$_}) - abs($distance1));
													$seq4read2{$_} = $str_adjustment.$seq4read2{$_};
													$seq4read1{$_} = substr($seq4read1{$_}, 0, length($seq4read1{$_}) - abs($distance1));
												}else{
													my $str_adjustment = substr($seq4read2{$_}, 0, abs($distance1));
													$seq4read1{$_} = $seq4read1{$_}.$str_adjustment;
													$seq4read2{$_} = substr($seq4read2{$_}, abs($diff_adjt));
												}
												push @loci_validated, $_ if $if_gtag != 0;
												$if_anno_add{$_} = 1;
												$candidate4mode_check{$_} = 2;
												###check for identical exon
												if($if_gtag !=0 and defined $identical_exon_filter and $_ eq $loci_validated[-1]){
													my $if_identical_exon = &check_identical_exon($site1{$_}, $site2{$_}, $chr_seq, $chr);
													pop @loci_validated if $if_identical_exon > 0;
												}
											}elsif(exists $candidate4mode_check{$_}){
												$candidate4mode_check{$_} = 3;
											}elsif($distance1 == $distance2){
												$candidate4mode_check{$_} = 6;
											}else{
												$candidate4mode_check{$_} = 7;
											}
											next READ;
										}elsif($pinhead == 4){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if ($candidate4mode_check{$_} == 1){
												$candidate4mode_check{$_} = 4;
											}else{
												$candidate4mode_check{$_} = 8;
											}
											next READ;
										}elsif($pinhead == 6){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if ($candidate4mode_check{$_} == 1){
												$candidate4mode_check{$_} = 4;
											}else{
												$candidate4mode_check{$_} = 8;
											}
											next READ;
										}else{
											push @if_passed, $gene;
										}
									#}else{
									#	push @if_passed, $gene;
									#}
								}
							}
							if (@if_passed != 0){
								$read_anno{$_} = 'intron';
								$anno_gene{$_} = \@if_passed;
								unless ($candidate4mode_check{$_} == 1){
									$candidate4mode_check{$_} = 9;
								}
							}elsif($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}elsif( $lociB+6 < $site1{$_} ){
							$j = $i;
							next;
						}elsif( $lociB+6 < $site2{$_} ){
							if ($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}elsif( $lociA-6 > $site1{$_} ){
							if ($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}
					}
				}
			}
		}
	}elsif(defined $ref_1file){
		open CHR1, "<", $ref_1file or die "cannot open $ref_1file: $!";
		my %chr_ref;
		my $tag4ref = 0;
		my $ref_ID;
		my @ref_not_found;
		for my $chr(@chr_type){
			$chr_ref{$chr} = '';
		}
		while(<CHR1>){
			chomp;
			if(/^>(\S+)/  and exists $chr_ref{$1}){
				$ref_ID = $1;
				$tag4ref = 1;
			}elsif(/^>/){
				$tag4ref = 0;
			}elsif($tag4ref == 1){
				$chr_ref{$ref_ID} .= $_;
			}
		}
		for my $chr(@chr_type){
			if(length($chr_ref{$chr}) == 0){
				push @ref_not_found, $chr;
			}
		}
		if (@ref_not_found > 0){
			print "The following references are not found in $ref_1file:\n";
			print @ref_not_found;
			print "\nPlease make sure the reference file provided here is the same one provided to BWA-MEM!\n";
			die;
		}
		for my $chr(@chr_type){
			if($if_gtag == 2){
				#my $read_in_chr = "read_in".$chr;
				for (@{$read_in_chr{$chr}}){
					$candidate4mode_check{$_} = 1;
				}
			}else{
				my $chr_seq = $chr_ref{$chr};
				#my $read_in_chr = "read_in".$chr;
				for (@{$read_in_chr{$chr}}){
					push @loci_validated, $_ if $if_gtag == 0;
					my ($end_string1, $end_string2);
					my $ori_site1 = $site1{$_}-$end_adjt1{$_};
					my $ori_site2 = $site2{$_}-$end_adjt2{$_};
					my $diff_adjt;
					my $pinhead = 0;
					my $total_adjustment = $end_adjt1{$_} + $end_adjt2{$_};
					if($end_adjt2{$_} >= 0){				
						$end_string1 = substr($chr_seq, $site1{$_}-$end_adjt1{$_}-4, 4+$end_adjt1{$_}+$end_adjt2{$_});
						$end_string2 = substr($chr_seq, $site2{$_}-$end_adjt1{$_}-1, 4+$end_adjt1{$_}+$end_adjt2{$_});
					}else{
						$end_string1 = substr($chr_seq, $site1{$_}+$end_adjt2{$_}-4, 4-$end_adjt1{$_}-$end_adjt2{$_});
						$end_string2 = substr($chr_seq, $site2{$_}+$end_adjt2{$_}-1, 4-$end_adjt1{$_}-$end_adjt2{$_});
					}
					my @index_compare_result = &index_compare($end_string1, $end_string2);
					if ( $index_compare_result[0] != 0 ){
						if ($index_compare_result[0] > 0){
							$positive_num1 ++;
							$sense_strand{$_} = $index_compare_result[2];
						}else{
							$positive_num2 ++;
							$sense_strand{$_} = $index_compare_result[2];
						}
						if($end_adjt2{$_} >= 0){
							$diff_adjt = $index_compare_result[1] - 1 - $end_adjt1{$_};
						}else{
							$diff_adjt = $index_compare_result[1] - 1 + $total_adjustment - $end_adjt1{$_};
						}
						push @loci_validated, $_ if $if_gtag != 0;
						$pinhead = 1;
					}else{
						$candidate4mode_check{$_} = 1;
					}
					if($pinhead == 1){
						$end_adjt1{$_} = $diff_adjt+$end_adjt1{$_};
						$end_adjt2{$_} = $total_adjustment - $end_adjt1{$_};
						$site1{$_} = $site1{$_}+$diff_adjt;
						$site2{$_} = $site2{$_}+$diff_adjt;
						if($diff_adjt > 0){
							my $str_adjustment = substr($seq4read2{$_}, 0, abs($diff_adjt));
							$seq4read1{$_} = $seq4read1{$_}.$str_adjustment;
							$seq4read2{$_} = substr($seq4read2{$_}, abs($diff_adjt));
						}elsif($diff_adjt < 0){
							my $str_adjustment = substr($seq4read1{$_}, length($seq4read1{$_}) - abs($diff_adjt));
							$seq4read2{$_} = $str_adjustment.$seq4read2{$_};
							$seq4read1{$_} = substr($seq4read1{$_}, 0, length($seq4read1{$_}) - abs($diff_adjt));
						}
						###check for identical exon
						if($if_gtag !=0 and defined $identical_exon_filter and $_ eq $loci_validated[-1]){
							my $if_identical_exon = &check_identical_exon($site1{$_}, $site2{$_}, $chr_seq, $chr);
							pop @loci_validated if $if_identical_exon > 0;
						}
					}
				}
			}
			if($if_anno == 1){
				@{$read_in_chr{$chr}} = sort { $site1{$a} <=> $site1{$b} or $site2{$a} <=> $site2{$b} } @{$read_in_chr{$chr}};
				my @genes_annotated = &sort_genes_in_chr( $chr );
				my @genes_group = @{$genes_annotated[0]};
				my @genes_group_ends = @{$genes_annotated[1]};
				my $j = 0;
				READ: for (@{$read_in_chr{$chr}}){
					for my $i( $j .. $#genes_group ){
						my @genes = @{$genes_group[$i]};
						my ($lociA, $lociB) = @{$genes_group_ends[$i]};
						if ( $lociA-6 <= $site1{$_} and $lociB+6 >= $site2{$_} ) {
							$j = $i;
							my @if_passed = ();
							for my $gene (@genes){
								my $loci1 = $gene_loci{$chr.":".$gene}[0];
								my $loci2 = $gene_loci{$chr.":".$gene}[1];
								my $pinhead;
								if ( $loci1-6 <= $site1{$_} and $loci2+6 >= $site2{$_} ) {
									my ($distance1, $distance2, $distance3, $distance4);
									#my $z;
									for my $x( 0 .. $#{$gene_exon{$chr.":".$gene}} ){
										$distance1 = $site1{$_} - $gene_exon{$chr.":".$gene}[$x][0];
										$distance3 = $site1{$_} - $gene_exon{$chr.":".$gene}[$x][1] + 6;
										if ( abs($distance1) <= 6 ){
											$pinhead = 1;
											#$z = $x;
											last;
										}elsif($distance1 > 6 and $distance3 <= 0){
											$pinhead = 3;
											#$z = $x;
											last;
										}
									}
									#if($pinhead == 1 or $pinhead == 3){
										for my $y( 0 .. $#{$gene_exon{$chr.":".$gene}} ){
											$distance2 = $site2{$_} - $gene_exon{$chr.":".$gene}[$y][1];
											$distance4 = $site2{$_} - $gene_exon{$chr.":".$gene}[$y][0] - 6;
											if ( abs($distance2) <= 6 ){
												$pinhead += 1;
												last;
											}elsif($distance2 < -6 and $distance4 >= 0){
												$pinhead += 3;
												last;
											}
										}
										if($pinhead == 2){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if(exists $candidate4mode_check{$_} and $distance1 == $distance2){
												$site1{$_} = $site1{$_} - $distance1;
												$site2{$_} = $site2{$_} - $distance2;
												if($distance1>0){
													my $str_adjustment = substr($seq4read1{$_}, length($seq4read1{$_}) - abs($distance1));
													$seq4read2{$_} = $str_adjustment.$seq4read2{$_};
													$seq4read1{$_} = substr($seq4read1{$_}, 0, length($seq4read1{$_}) - abs($distance1));
												}else{
													my $str_adjustment = substr($seq4read2{$_}, 0, abs($distance1));
													$seq4read1{$_} = $seq4read1{$_}.$str_adjustment;
													$seq4read2{$_} = substr($seq4read2{$_}, abs($diff_adjt));
												}
												push @loci_validated, $_ if $if_gtag != 0;
												$if_anno_add{$_} = 1;
												$candidate4mode_check{$_} = 2;
												###check for identical exon
												if($if_gtag !=0 and defined $identical_exon_filter and $_ eq $loci_validated[-1]){
													my $if_identical_exon = &check_identical_exon($site1{$_}, $site2{$_}, $chr_seq, $chr);
													pop @loci_validated if $if_identical_exon > 0;
												}
											}elsif(exists $candidate4mode_check{$_}){
												$candidate4mode_check{$_} = 3;
											}elsif($distance1 == $distance2){
												$candidate4mode_check{$_} = 6;
											}else{
												$candidate4mode_check{$_} = 7;
											}
											next READ;
										}elsif($pinhead == 4){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if ($candidate4mode_check{$_} == 1){
												$candidate4mode_check{$_} = 4;
											}else{
												$candidate4mode_check{$_} = 8;
											}
											next READ;
										}elsif($pinhead == 6){
											$read_anno{$_} = 'exon';
											$anno_gene{$_} = $gene;
											if ($candidate4mode_check{$_} == 1){
												$candidate4mode_check{$_} = 4;
											}else{
												$candidate4mode_check{$_} = 8;
											}
											next READ;
										}else{
											push @if_passed, $gene;
										}
									#}else{
									#	push @if_passed, $gene;
									#}
								}
							}
							if (@if_passed != 0){
								$read_anno{$_} = 'intron';
								$anno_gene{$_} = \@if_passed;
								unless ($candidate4mode_check{$_} == 1){
									$candidate4mode_check{$_} = 9;
								}
							}elsif($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}elsif( $lociB+6 < $site1{$_} ){
							$j = $i;
							next;
						}elsif( $lociB+6 < $site2{$_} ){
							if ($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}elsif( $lociA-6 > $site1{$_} ){
							if ($candidate4mode_check{$_} == 1){
								$candidate4mode_check{$_} = 5;
							}else{
								$candidate4mode_check{$_} = 0;
							}
							last;
						}
					}
				}
			}
		}
		%chr_ref = ();
	}
}
sub check_identical_exon{
		my ($start, $end, $seq, $chr) = @_;
		my $seq1 = substr ($seq, $start-1, $identical_exon_length);
		my $seq2 = substr ($seq, $end-$identical_exon_length, $identical_exon_length);
		#print "!!1: $chr:$start:$end\t$seq1\n";
		#print "!!2: $chr:$start:$end\t$seq2\n";
		my (@multiple_loci1, @multiple_loci2);
		my ($chr_seq4loci1, $chr_seq4loci2);
		my $seq_length = length($seq);
		#print "0: $start\t$end\t$seq1\t$seq2\t$seq_length\t$chr\n"; 
		if($end+$identical_exon_dist <= $seq_length){
			$chr_seq4loci1 = substr($seq, $end, $identical_exon_dist);
		}else{
			$chr_seq4loci1 = substr($seq, $end, $seq_length-$end);
		}
		if($start >= $identical_exon_dist+1){
			$chr_seq4loci2 = substr($seq, $start-$identical_exon_dist-1, $identical_exon_dist);
		}else{
			$chr_seq4loci2 = substr($seq, 0, $start);
		}
		if ($chr_seq4loci2 =~ /$seq2(.*)/i){
			push @multiple_loci2, length($1);
		}
		if ($chr_seq4loci1 =~ /(.*)$seq1/i){
			push @multiple_loci1, length($1);
		}
		#if (@multiple_loci1 >= 1 ){
		#	print "1:\t$chr:$start:$end\t@multiple_loci1\n";
		#}
		#if (@multiple_loci2 >= 1 ){
		#	print "2:\t$chr:$start:$end\t@multiple_loci2\n";
		#}
		@multiple_loci1 + @multiple_loci2;
}

sub index_compare{
	my %base_index;
	my @bibase1 = ('AC', 'AG');
	my @bibase2 = ('CT', 'GT');
	my @result;
	my $strand_gtf;
	my $hint = 0;
	for my $i(@bibase1){
		my $pre_index = -1;
		while(1){
			my $index = index("\U$_[0]", $i, $pre_index+1);
			last if $index == -1;
			push @{$base_index{$i}}, $index;
			$pre_index = $index;
		}
	}
	for my $i(@bibase2){
		my $pre_index = -1;
		while(1){
			my $index = index("\U$_[1]", $i, $pre_index+1);
			last if $index == -1;
			push @{$base_index{$i}}, $index;
			$pre_index = $index;
		}
	}
	if( defined $base_index{'AC'} and defined $base_index{'CT'} ){
		@result = grep {$_ ~~ @{$base_index{'CT'}} } @{$base_index{'AC'}};
		$hint = 1 if @result>0;
		$strand_gtf = '-';
	}elsif( defined $base_index{'AG'} and defined $base_index{'GT'} ){
		@result = grep {$_ ~~ @{$base_index{'GT'}} } @{$base_index{'AG'}};
		$hint = -1 if @result>0;
		$strand_gtf = '+';
	}
	($hint, $result[0], $strand_gtf);
}
## debugged
sub record_candidate_reads{
	my @array1 = @{$_[0]};
	my @array2 = @{$_[1]};
	my @read2_scale = @{$array2[-1]};
	my @read1_circle = @{$array1[1]};
	for my $i(@read1_circle){
		for my $j(@read2_scale){
			my @read1_pos = @$i;
			my @read2_pos = @$j;
			if ($read1_pos[1] eq $read2_pos[1] and $read1_pos[0] ne $read2_pos[0] and $read2_pos[2] >= $read1_pos[2]-6 and $read2_pos[3] <= $read1_pos[3]+6){
				push @candidate_reads, $read1_pos[-1] unless $read1_pos[-1] eq $candidate_reads[-1];
				$chr{$read1_pos[-1]} = $read1_pos[1];
				$site1{$read1_pos[-1]} = $read1_pos[2];
				$site2{$read1_pos[-1]} = $read1_pos[3];
				$seq4read1{$read1_pos[-1]} = $read1_pos[4];
				$seq4read2{$read1_pos[-1]} = $read1_pos[5];
				$end_adjt1{$read1_pos[-1]} = $read1_pos[6];
				$end_adjt2{$read1_pos[-1]} = $read1_pos[7];
				$cigar_read{$read1_pos[-1]} = $read1_pos[8];
				$if_1st_read{$read1_pos[-1]} = $read1_pos[9];

			}
		}
	}
}
## debugged
## input all mapping information for a group of PE reads from main routine;
## no output;
## invoke sub mapping_check2: specifically analyse mapping information;
## invoke sub record_candidate_reads: record candiate reads qualified by mapping_check2;
sub mapping_check1{
	my (@read_IDs, @read1, @read2);
	for(@_){
		my @line = split (/\t/, $_, 3);
		if(&ten2b($line[1],7) == 1){
			push @read1, $_;
		}else{
			push @read2, $_;
		}
	}
	my @mapping_analysis1 = &mapping_check2(@read1);
	my @mapping_analysis2 = &mapping_check2(@read2);
	if ($if_PE == 2){
		if($mapping_analysis1[0] >= 1){
			&record_candidate_reads(\@mapping_analysis1, \@mapping_analysis2);	
		}if($mapping_analysis2[0] >= 1){
			&record_candidate_reads(\@mapping_analysis2, \@mapping_analysis1);
		}
	}else{
		my @read1_circle;
		if(@{$mapping_analysis1[1]}>0){
			@read1_circle = @{$mapping_analysis1[1]};
		}elsif(@{$mapping_analysis2[1]}>0){
			@read1_circle = @{$mapping_analysis2[1]};
		}
		if(@read1_circle>0){
			@array_read = @{$read1_circle[0]};
			push @candidate_reads, $array_read[-1] unless $array_read[-1] eq $candidate_reads[-1];
			$chr{$array_read[-1]} = $array_read[1];
			$site1{$array_read[-1]} = $array_read[2];
			$site2{$array_read[-1]} = $array_read[3];
			$seq4read1{$array_read[-1]} = $array_read[4];
			$seq4read2{$array_read[-1]} = $array_read[5];
			$end_adjt1{$array_read[-1]} = $array_read[6];
			$end_adjt2{$array_read[-1]} = $array_read[7];
			$cigar_read{$array_read[-1]} = $array_read[8];
			$if_1st_read{$array_read[-1]} = $array_read[9];
		}
	}
}
## debugged
## input all mapping information for a read of PE reads from sub mapping_check1;
## output @output: $detected for 
sub mapping_check2{
	my (@strand, @chr, @pos, @match, $detected, @attributes, @circle_start_end, @output, $z, $str1, $str2, @cigar, $first_read, @MAPQ);
	my $seq = '';
	my ($read_name, $flag);
	my @line = split (/\t/, $_[0], 3);
	if($line[0] =~ m%^(.+)/[12]$% or $line[0] =~ m%^(.+)_[12]$%){
		$read_name = $1;
		$flag = $line[1];
	}else{
		($read_name, $flag) = ($line[0], $line[1]);
	}
	my $first_read = &ten2b($flag, 7);
	for(@_){
		my @line = split /\t/;
		push @strand, &ten2b($line[1], 5);
		push @chr, $line[2];
		push @pos, $line[3];
		push @MAPQ, $line[4];
		push @cigar, $line[5];
		my $MSID = &MSID($line[5]);
		push @match, $MSID;
		if ($seq eq '' and length($line[9]) == $read_length){
			$seq = $line[9];
			$z = $strand[-1];
		}
		my @length = @$MSID;
		if($length[-1] > 0){
			push @attributes, [$strand[-1], $line[2], $line[3], $line[3]+$length[-1]-1, $read_name];
		}else{
			push @attributes, [0, 0, 0, 0, $read_name];
		}
	}
	for my $i(0 .. $#_-1){
		for my $j($i+1 .. $#_){
			if($chr[$i] eq $chr[$j] and $strand[$i] == $strand[$j]){
				if ($strand[$i] != $z){
					$seq = &comp_rev($seq);
					$z = $strand[$i];
				}
				if(${$match[$i]}[0]*${$match[$j]}[0] == -1){
					my @match1 = @{$match[$i]};
					my @match2 = @{$match[$j]};
					my $cir_scale = $match1[0]*($pos[$i]+$match1[2])+$match2[0]*($pos[$j]+$match2[2]);
					if(abs($match1[1]-$match2[1])<=6 and $cir_scale > 0 and $cir_scale <= $max_circle and $MAPQ[$i] >= $mapq_uni and $MAPQ[$j] >= $mapq_uni and $MAPQ[$i]+$MAPQ[$j] >= $mapq_both){
						$detected ++;
						my @pos_com = sort{$a <=> $b}($pos[$i]+$match1[2], $pos[$j]+$match2[2]);
						my $end_adjustment1 = int(($match1[1]*$match1[0]+$match2[1]*$match2[0])/2);
						my $end_adjustment2 = $match1[1]*$match1[0]+$match2[1]*$match2[0] - $end_adjustment1;					
						if($match1[0] == -1){
							$str1 = substr($seq, 0, $match1[1]+$end_adjustment1);
							$str2 = substr($seq, $match1[1]+$end_adjustment1);
						}else{
							$str1 = substr($seq, 0, $match1[1]-$end_adjustment2);
							$str2 = substr($seq, $match1[1]-$end_adjustment2);
						}
						my($x, $y) = sort {${$match[$a]}[0] <=> ${$match[$b]}[0]} ($i, $j);
						my $CIGAR = [$cigar[$x], $cigar[$y], undef];
						push @circle_start_end, [$strand[$i], $chr[$i], ($pos_com[0]+$end_adjustment1), ($pos_com[1]-$end_adjustment2), $str1, $str2, $end_adjustment1, $end_adjustment2, $CIGAR, $first_read, $read_name]; #"$strand[$i]!!$chr[$i]!!".($pos_com[0]+$end_adjustment1)."!!".($pos_com[1]-$end_adjustment2)."!!$str1!!$str2!!$end_adjustment1!!$end_adjustment2!!$read_name[0]";
					}
				}elsif(abs(${$match[$i]}[0]*${$match[$j]}[0]) == 10){
					my($x, $y) = sort {${$match[$a]}[0] <=> ${$match[$b]}[0]} ($i, $j);
					if(${$match[$x]}[0] == -1){
						my $cir_scale = $pos[$y]+${$match[$y]}[-1]-1-$pos[$x];
						if(abs($read_length-${$match[$y]}[2]-${$match[$x]}[1])<=6 and $cir_scale > 0 and $cir_scale <= $max_circle and $MAPQ[$i] >= $mapq_uni and $MAPQ[$j] >= $mapq_uni and $MAPQ[$i]+$MAPQ[$j] >= $mapq_both){
							$detected ++;
							my $end_adjustment1 = int((${$match[$y]}[1]+${$match[$y]}[-1]-${$match[$x]}[1])/2);
							my $end_adjustment2 = ${$match[$y]}[1]+${$match[$y]}[-1]-${$match[$x]}[1]-$end_adjustment1;
							$str2 = substr($seq, ${$match[$x]}[1]+$end_adjustment1);
							$str1 = substr($seq, ${$match[$y]}[1], ${$match[$x]}[1]+$end_adjustment1-${$match[$y]}[1]);
							my $CIGAR = [$cigar[$x], undef, $cigar[$y]];
							push @circle_start_end,	[$strand[$x], $chr[$x], ($pos[$x]+$end_adjustment1),($pos[$y]+${$match[$y]}[-1]-1-$end_adjustment2), $str1, $str2, $end_adjustment1, $end_adjustment2, $CIGAR, $first_read, $read_name];
						}
					}else{
						my $cir_scale = $pos[$x]+${$match[$x]}[-1]-1-$pos[$y];
						if(abs(${$match[$x]}[1]-${$match[$y]}[1])<=6 and $cir_scale > 0 and $cir_scale <= $max_circle and $MAPQ[$i] >= $mapq_uni and $MAPQ[$j] >= $mapq_uni and $MAPQ[$i]+$MAPQ[$j] >= $mapq_both){
							$detected ++;
							my $end_adjustment1 = int((${$match[$x]}[1]-${$match[$y]}[1])/2);
							my $end_adjustment2 = ${$match[$x]}[1]-${$match[$y]}[1] - $end_adjustment1;
							$str1 = substr($seq, 0, ${$match[$x]}[1]-$end_adjustment2);
							$str2 = substr($seq, ${$match[$x]}[1]-$end_adjustment2, $read_length-${$match[$y]}[2]-${$match[$x]}[1]-$end_adjustment2);
							my $CIGAR = [undef, $cigar[$x], $cigar[$y]];
							push @circle_start_end, [$strand[$x], $chr[$x], ($pos[$y]+$end_adjustment1), ($pos[$x]+${$match[$x]}[-1]-1-$end_adjustment2), $str1, $str2, $end_adjustment1, $end_adjustment2, $CIGAR, $first_read, $read_name];
						}
					}
				}
			}
		}
	}
	@output = ($detected, \@circle_start_end, \@attributes);
}
sub comp_rev{
	my $seq = reverse($_[0]);
	$seq =~ s/A/X/g;
	$seq =~ s/T/A/g;
	$seq =~ s/X/T/g;
	$seq =~ s/C/Y/g;
	$seq =~ s/G/C/g;
	$seq =~ s/Y/G/g;
	$seq;
}
## debugged
sub MSID{
	my($M_sum, $S_num, $S_num1, $S_num2, @I_num, @D_num, $I_sum, $D_sum, $pos_adjustment, $length);
	if($_[0] =~ /^(\d+)[SH].+M$/){
		$S_num = $1;
		@I_num = ($_[0] =~ /(\d+)I/g);
		@D_num = ($_[0] =~ /(\d+)D/g);
		$I_sum += $_ for @I_num;
		$D_sum += $_ for @D_num;
		$length = $D_sum - $I_sum + $read_length - $S_num;
		[-1, $S_num, 0, $length];
	}elsif($_[0] =~ /^\d+M.*?(\d+)[SH]$/){
		$M_sum = $read_length - $1;
		@I_num = ($_[0] =~ /(\d+)I/g);
		@D_num = ($_[0] =~ /(\d+)D/g);
		$I_sum += $_ for @I_num;
		$D_sum += $_ for @D_num;
		$pos_adjustment = $D_sum - $I_sum + $M_sum - 1;
		$length = $pos_adjustment+1;
		[1, $M_sum, $pos_adjustment, $length];
	}elsif($_[0] =~ /^($read_length)M$/){
		[0, 0, 0, $read_length];
	}elsif($_[0] =~ /^(\d+)[SH].+?(\d+)[SH]$/){
		$S_num1 = $1;
		$S_num2 = $2;
		$S_num = $1+$2;
		@I_num = ($_[0] =~ /(\d+)I/g);
		@D_num = ($_[0] =~ /(\d+)D/g);
		$I_sum += $_ for @I_num;
		$D_sum += $_ for @D_num;
		$length = $D_sum - $I_sum + $read_length - $S_num;
		[10, $S_num1, $S_num2, $length];
	}else{
		[0, undef, undef, -1];
	}
}
## debugged
sub ten2b{
	my $b_string = sprintf("%b", $_[0]);
	if ($_[1] <= length($b_string)){
		substr(reverse($b_string), $_[1]-1, 1);
	}else{
		0;
	}
}